"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[428],{7216:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>i,toc:()=>c});var o=n(5893),s=n(1151);const t={sidebar_position:16},r="Redirecci\xf3n de salida y tuber\xedas",i={id:"bash/stdoutput_pipes",title:"Redirecci\xf3n de salida y tuber\xedas",description:"Salida est\xe1ndar (STDOUT)",source:"@site/docs/bash/stdoutput_pipes.md",sourceDirName:"bash",slug:"/bash/stdoutput_pipes",permalink:"/bioinformatica_esp/docs/bash/stdoutput_pipes",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:16,frontMatter:{sidebar_position:16},sidebar:"tutorialSidebar",previous:{title:"Comando sort",permalink:"/bioinformatica_esp/docs/bash/sort"},next:{title:"Creaci\xf3n de un script",permalink:"/bioinformatica_esp/docs/bash/script"}},l={},c=[{value:"Salida est\xe1ndar (STDOUT)",id:"salida-est\xe1ndar-stdout",level:2},{value:"Tuber\xedas (pipes)",id:"tuber\xedas-pipes",level:2}];function d(e){const a={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.h1,{id:"redirecci\xf3n-de-salida-y-tuber\xedas",children:"Redirecci\xf3n de salida y tuber\xedas"}),"\n",(0,o.jsx)(a.h2,{id:"salida-est\xe1ndar-stdout",children:"Salida est\xe1ndar (STDOUT)"}),"\n",(0,o.jsx)(a.p,{children:"Empezaremos definiendo la salida estandar (STDOUT), al ejecutar un comando el resultado por default se va a mostrar en la consola de la terminar, es decir, nuestra pantalla del ordenador."}),"\n",(0,o.jsx)(a.p,{children:"La salida del comando ls representa una salida estandar"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-bash",children:"ls -l\n"})}),"\n",(0,o.jsxs)(a.p,{children:["Siempre que se ejecute un comando veremos el resultado en nuestra pantalla, sin embargo nosotros podemos redirigir esta salida y enviarla a un archivo o documento, para esto ocuparemos el s\xedmbolo de mayor que ",(0,o.jsx)(a.code,{children:">"}),", al hacer esto nosotros estaremos creando un nuevo documento con la informaci\xf3n de salida del comando que ejecutemos."]}),"\n",(0,o.jsxs)(a.p,{children:["Crear un archivo que contenga el resultado del comando ",(0,o.jsx)(a.code,{children:"ls -l"})," y que se llame listado.txt"]}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-bash",children:"ls -l > listado.txt\n"})}),"\n",(0,o.jsx)(a.p,{children:"El archivo que nosotros creamos contiene el resultado del comando ls -l."}),"\n",(0,o.jsxs)(a.p,{children:["Si nosotros deseamos adicionar contenido a un archivo existente lo podemos hacer empleando ",(0,o.jsx)(a.code,{children:">>"}),", veamos un ejemplo:"]}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-bash",children:"# Crearemos dos archios en vim, uno llamado numeros.txt que contenga lo siguiente:\n1\n2\n3\n4\n5\n6\n\n#Y otro archivo llamado faltantes.txt que contenga lo siguiente:\n7\n8\n9\n10\n11\n\n# Posteriormente a\xf1adiremos al archivo numeros.txt los numeros que contiene el archivo faltantes.txt. Al ocupar >> estamos indicando que la informacion de\n\nmore faltantes.txt >> numeros.txt  faltantes.txt \n\n#Ahora al abrir el archivo numeros.txt este contiene tambien los numeros que se encontraban en el archivo faltantes.txt.\n\nmore numeros.txt \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n"})}),"\n",(0,o.jsx)(a.h2,{id:"tuber\xedas-pipes",children:"Tuber\xedas (pipes)"}),"\n",(0,o.jsx)(a.p,{children:"El uso de pipes o tuberias es muy com\xfan cuando se trabaja en Unix, estas nos sirven para encadenar una serie de comandos para llegar a un resultado en un \u201cs\xf3lo paso\u201d, es decir, en lugar de teclear todos los comandos por separado, estos se pueden encadenar y hacerlo en \u201cun solo comando\u201d para esto nosotros utilizamos el s\xedbolo \u201c|\u201d. Veamos un ejemplo:"}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-bash",children:'# Tenemos un archivo multifasta que contiene secuencias de prote\xednas, de este archivo  queremos extraer las prote\xednas ribosomales y despu\xe9s saber cuantas tenemos. Empecemos haciendolo por partes y seguido de esto empleando el uso de tuberias.\n\n\n# Empecemos por extraer las proteinas ribosomales que contiene el archivo empleando grep y creando un archivo nuevo que llamaremos ribosomales.txt\n\ngrep "ribosomal protein" GCF_002284945.1_ASM228494v1_protein > ribosomales.txt \n.faa\n\nmore ribosomales.txt \n\n>WP_018604832.1 50S ribosomal protein L34 [Uliginosibacterium gangwonense]\n>WP_095523304.1 50S ribosomal protein L3 N(5)-glutamine methyltransferase [Candidatus Dactylopiibacterium carminicum]\n>WP_095523490.1 30S ribosomal protein S21 [Candidatus Dactylopiibacterium carminicum]\n>WP_095524063.1 50S ribosomal protein L28 [Candidatus Dactylopiibacterium carminicum]\n>WP_095524064.1 50S ribosomal protein L33 [Candidatus Dactylopiibacterium carminicum]\n>WP_095524081.1 50S ribosomal protein L9 [Candidatus Dactylopiibacterium carminicum]\n\n# Posteriormente con el comando wc contamos cuantas proteinas ribosomales hay.\nwc -l ribosomales.txt   \n58 ribosomales.txt\n\n# Ahora hagamoslo todo en un s\xf3lo paso: Encadenamos el resultado del grep al siguiente comando que es wc, con esto extraemos y contamos en una sola operaci\xf3n.\n\ngrep "ribosomal protein " GCF_002284945.1_ASM228494v1_protein.faa | wc -l\n\n58\n'})})]})}function u(e={}){const{wrapper:a}={...(0,s.a)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>i,a:()=>r});var o=n(7294);const s={},t=o.createContext(s);function r(e){const a=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(t.Provider,{value:a},e.children)}}}]);